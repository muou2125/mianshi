<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="503"/>

<div>
<span><div><div><span style="font-weight: bold;">Javascript 原型链的理解： 封装、继承、多态</span></div><div><br/></div><div><span style="font-weight: bold;">1、javascript的typeof返回哪些数据类型</span></div><ul><li><div>string</div></li><li><div>boolean</div></li><li><div>number</div></li><li><div>undefined</div></li><li><div>function</div></li><li><div>object</div></li></ul><div><br/></div><div><span style="font-weight: bold;">2、例举3种强制类型转换和2种隐式类型转换?</span></div><ul><li><div>强制（parseInt，parseFloat，number）</div></li><li><div>隐式（==  ===）</div></li></ul><div><br/></div><div><span style="font-weight: bold;">3、split() join() 的区别</span></div><ul><li><div>split 将字符串切割成数组的形式</div></li><li><div>join 将数组转换成字符串</div></li></ul><div><br/></div><div><span style="font-weight: bold;">4、数组方法pop() push() unshift() shift()</span></div><ul><li><div>push() 尾部添加</div></li><li><div>pop()  尾部删除</div></li><li><div>unshift()  头部添加</div></li><li><div>shift()  头部删除</div></li></ul><div><br/></div><div><span style="font-weight: bold;">5、IE和标准下有哪些兼容性的写法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var ev = ev || window.event</div><div>document.documentElement.clientWidth || document.body.clientWidth</div><div>Var target = ev.srcElement || ev.target</div></div><div><br/></div><div><span style="font-weight: bold;">6、call 和 apply</span></div><ul><li><div>Object.call(this, obj1, obj2, obj3)</div></li><li><div>Object.apply(this, arguments)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//call</span></div><div>myFunction.call(myObject, 10, 2); // 返回 20</div><div><br/></div><div>//apply </div><div>myArray = [10, 2];</div><div>myObject = myFunction.apply(myObject, myArray); // 返回 20</div></div><div><br/></div><div><span style="font-weight: bold;">call() 和 apply() 的相同点：</span></div><ul><li><div>方法的第一个参数都是对象本身</div></li><li><div>都可以改变 this 的指向</div></li></ul><div><br/></div><div><span style="font-weight: bold;">call() 和 apply() 的区别：</span></div><ul><li><div>call()     将数组值作为参数依次一个个传入</div></li><li><div>apply()  将数组当做参数一次传入</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">7、ajax请求时，如何解析json数据</span></div><div>使用 JSON.parse</div><div><br/></div><div><span style="font-weight: bold;">8. 事件委托是什么</span></div><div>利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行</div><div><br/></div><div><span style="font-weight: bold;">9、闭包是什么，有什么特性，对页面有什么影响</span></div><div>闭包就是能够读取其他函数内部变量的函数，使得函数不被垃圾回收，如果过多使用闭包，容易导致内存泄露</div><div><br/></div><div><span style="font-weight: bold;">10、如何阻止事件冒泡</span></div><ul><li><div>ie：ev.cancelBubble = true;</div></li><li><div>非IE：ev.stopPropagation();</div></li></ul><div><br/></div><div><span style="font-weight: bold;">11、如何阻止默认事件</span></div><ul><li><div>return false；</div></li><li><div>ev.preventDefault();</div></li></ul><div><br/></div><div><span style="font-weight: bold;">12、添加 删除 替换 插入到某个接点的方法</span></div><ul><li><div>创建新节点</div></li><ul><li><div>createElement() //创建一个具体的元素</div></li><li><div>createTextNode() //创建一个文本节点</div></li></ul><li><div>添加、移除、替换、插入</div></li><ul><li><div>appendChild() //添加</div></li><li><div>removeChild() //移除</div></li><li><div>replaceChild() //替换</div></li><li><div>insertBefore() //插入</div></li></ul><li><div>查找</div></li><ul><li><div>getElementsByTagName() //通过标签名称</div></li><li><div>getElementsByName() //通过元素的Name属性的值</div></li><li><div>getElementById() //通过元素Id，唯一性</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">13、解释 jsonp 的原理，以及为什么不是真正的 ajax</span></div><div>动态创建 script 标签，回调函数</div><div>Ajax是页面无刷新请求数据操作</div><div><br/></div><div><span style="font-weight: bold;">14、document load 和 document ready 的区别</span></div><div>document.onload 是在结构和样式,外部js以及图片加载完才执行js</div><div>document.ready是dom树创建完成就执行的方法，原生中没有这个方法，jquery中才有 $().ready(function(){})</div><div><br/></div><div><span style="font-weight: bold;">15、== 和 === 的不同</span></div><div>== 会自动转换类型，再判断是否相等</div><div>=== 不会自动类型转换，直接去比较</div><div><br/></div><div><span style="font-weight: bold;">16、函数声明与函数表达式的区别？</span></div><div>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行</div><div><br/></div><div><span style="font-weight: bold;">17、对作用域上下文和this的理解，看下列代码：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var User = {</div><div>    count: 1,</div><div>    getCount: function() {</div><div>        return this.count;</div><div>    }</div><div>};</div><div>console.log(User.getCount()); // what?</div><div><br/></div><div>var func = User.getCount;</div><div>console.log(func()); // what?</div></div><div><br/></div><div>问两处console输出什么？为什么？</div><div><span style="font-weight: bold;">输出结果为：1 和 undefined</span></div><div>因为 func 是在 window 的上下文中被执行的，所以不会访问到 count 属性</div><div><br/></div><div><span style="font-weight: bold;">18、看下面代码，给出输出结果</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for(var i = 1; i &lt;= 3; i++){ //建议使用let 可正常输出i的值</div><div><span>    console.log(i);</span><br/></div><div>    setTimeout(function(){</div><div>        console.log(i);</div><div>    },0);</div><div>};</div><div><br/></div><div>结果：</div><div>1 2 3</div><div>4 4 4</div><div>因为Javascript事件处理器在线程空闲之前不会运行</div></div><div><br/></div><div><span style="font-weight: bold;">19、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做?</span></div><ul><li><div>box.onlick= function(){}</div></li><li><div>box.addEventListener(&quot;click&quot;,function(){},false);</div></li><li><div>&lt;button onclick=&quot;xxx()&quot;&gt;&lt;/button&gt;</div></li></ul><div><br/></div><div><span style="font-weight: bold;">20、Javascript的事件流模型都有什么?</span></div><ul><li><div>事件冒泡：事件开始由最具体的元素接受，然后逐级向上传播</div></li><li><div>事件捕捉：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的</div></li><li><div>DOM事件流：</div></li><ul><li><div>三个阶段：事件捕捉，目标阶段，事件冒泡</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">21、看下列代码,输出什么?解释原因</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var a = null;</div><div>alert(typeof a);</div><div><br/></div><div>结果：</div><div>object</div><div>因为null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回object</div></div><div><br/></div><div><span style="font-weight: bold;">22、判断字符串以字母开头，后面可以是数字，下划线，字母，长度为6-30</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var reg=/^[a-zA-Z]\w{5,29}$/;</div></div><div><br/></div><div><span style="font-weight: bold;">23、回答以下代码，alert的值分别是多少</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;script&gt;</div><div>    var a = 100;</div><div>    function test(){</div><div>        alert(a);</div><div>        a = 10; //去掉了var 就变成定义了全局变量了</div><div>        alert(a);</div><div>    }</div><div>    test();</div><div>    alert(a);</div><div>&lt;/script&gt;</div><div><br/></div><div>结果：</div><div>100， 10， 10</div></div><div><br/></div><div><span style="font-weight: bold;">24、javaScript的2种变量范围有什么不同？</span></div><ul><li><div>全局变量：当前页面内有效</div></li><li><div>局部变量：函数方法内有效</div></li></ul><div><br/></div><div><span style="font-weight: bold;">25、null和undefined的区别？</span></div><ul><li><div>null是一个表示&quot;无&quot;的对象，转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN</div></li><li><div>当声明的变量还未被初始化时，变量的默认值为undefined</div></li></ul><div><br/></div><div>undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义</div><div><span style="font-weight: bold;">典型用法是：</span></div><ul><li><div>变量被声明了，但没有赋值时，就等于undefined</div></li><li><div>调用函数时，应该提供的参数没有提供，该参数等于undefined</div></li><li><div>对象没有赋值的属性，该属性的值为undefined</div></li><li><div>函数没有返回值时，默认返回undefined</div></li></ul><div><br/></div><div>null表示&quot;没有对象&quot;，即该处不应该有值</div><div><span style="font-weight: bold;">典型用法是：</span></div><ul><li><div>作为函数的参数，表示该函数的参数不是对象</div></li><li><div>作为对象原型链的终点</div></li></ul><div><br/></div><div><span style="font-weight: bold;">26、new操作符具体干了什么呢?</span></div><ul><li><div>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</div></li><li><div>属性和方法被加入到 this 引用的对象中</div></li><li><div>新创建的对象由 this 所引用，并且最后隐式的返回 this </div></li></ul><div><br/></div><div><span style="font-weight: bold;">27、js延迟加载的方式有哪些？</span></div><ul><li><div>defer和async</div></li><li><div>动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）</div></li><li><div>按需异步载入js</div></li></ul><div><br/></div><div><span style="font-weight: bold;">28、Flash、Ajax各自的优缺点，在使用中如何取舍？</span></div><div><span style="font-weight: bold;">不同：</span></div><ul><li><div>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索</div></li><li><div>ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足</div></li></ul><div><span style="font-weight: bold;">共同点：</span></div><ul><li><div>与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</div></li></ul><div><br/></div><div><span style="font-weight: bold;">29、写一个获取非行间样式的函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function getStyle(obj,attr) {</div><div>    if(obj.currentStyle) {</div><div>        return obj.currentStyle[attr];</div><div>    }else{</div><div>        getComputedStyle(obi,false)[attr]</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">30、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var inputs = document.getElementsByTagName(&quot;input&quot;);//获取所有的input标签对象</div><div>var checkboxArray = [];//初始化空数组，用来存放checkbox对象。</div><div>for(var i=0;i&lt;inputs.length;i++){</div><div>    var obj = inputs[i];</div><div>    if(obj.type=='checkbox'){</div><div>        checkboxArray.push(obj);</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">31、写一个function，清除字符串前后的空格。（兼容所有浏览器）</span></div><ul><li><div>第一种</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>String.prototype.trim= function(){</div><div>    return this.replace(/^\s+/,&quot;&quot;).replace(/\s+$/,&quot;&quot;);</div><div>}</div></div><ul><li><div>第二种</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function trim(str) {</div><div>    if (str &amp; typeof str === &quot;string&quot;) {</div><div>        return str.replace(/(^s*)|(s*)$/g,&quot;&quot;); //去除前后空白符</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">32、javascript语言特性中，有很多方面和我们接触的其他编程语言不太一样,请举例</span></div><ul><li><div>javascript语言实现继承机制的核心就是 (原型)，而不是Java语言那样的类式继承</div></li><li><div>Javascript解析引擎在读取一个Object的属性的值时，会沿着 (原型链)向上寻找，如果最终没有找到，则该属性值为 undefined；如果最终找到该属性的值，则返回结果</div></li><li><div>与这个过程不同的是，当javascript解析引擎执行“给一个Object的某个属性赋值”的时候，如果当前Object存在该属性，则改写该属性的值，如果当前的Object本身并不存在该属性，则赋值该属性的值</div></li></ul><div><br/></div><div><span style="font-weight: bold;">33、Cookie在客户机上是如何存储的</span></div><div>Cookies就是服务器暂存放在你的电脑里的文本文件，好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookies 会帮你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。</div><div><br/></div><div><span style="font-weight: bold;">34、如何获取javascript三个数中的最大值和最小值？</span></div><div>Math.max(a,b,c);//最大值</div><div>Math.min(a,b,c)//最小值</div><div><br/></div><div><span style="font-weight: bold;">35、javascript是面向对象的，怎么体现javascript的继承关系？</span></div><div>使用prototype原型来实现</div><div><br/></div><div><span style="font-weight: bold;">36、列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型</span></div><div>主要数据类型：string, boolean, number</div><div>复合数据类型：function, object</div><div>特殊类型：undefined，null</div><div><br/></div><div><span style="font-weight: bold;">37、程序中捕获异常的方法？</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try{</div><div>    //要执行的代码</div><div>}catch(e){</div><div>    //错误处理函数</div><div>}finally{</div><div>    //无论代码是否有错都会执行</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">38、Ajax原理</span></div><ul><li><div>创建对象</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var xhr = new XMLHttpRequest();</div></div><ul><li><div>打开请求</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>xhr.open('GET', 'example.txt', true);</div></div><ul><li><div>发送请求</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>xhr.send(); 发送请求到服务器</div></div><ul><li><div>接收响应</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>xhr.onreadystatechange =function(){}</div></div><ol><li><div>当readystate值从一个值变为另一个值时，都会触发readystatechange事件</div></li><li><div>当readystate==4时，表示已经接收到全部响应数据</div></li><li><div>当status ==200时，表示服务器成功返回页面和数据</div></li><li><div>如果2和3内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容</div></li></ol><div><br/></div><div><span style="font-weight: bold;">39、解释什么是JSON</span></div><ul><li><div>JSON 是一种轻量级的数据交换格式</div></li><li><div>JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言</div></li><li><div>JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</div></li></ul><div><br/></div><div><span style="font-weight: bold;">40、js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</span></div><ul><li><div>alert</div></li><li><div>confirm</div></li><li><div>prompt</div></li></ul><div><br/></div><div><span style="font-weight: bold;">41、以下代码执行结果</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var uname = 'jack'function change() {</div><div>    alert(uname) // ?</div><div>    var uname = 'lily'</div><div>    alert(uname) //?</div><div>}</div><div>change()</div><div><br/></div><div>结果：</div><div>alert 分别弹出 undefined，lily，（变量声明提前问题）</div></div><div><br/></div><div><span style="font-weight: bold;">42、浏览器的滚动距离</span></div><div>可视区域距离页面顶部的距离</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>scrollTop = document.documentElement.scrollTop || document.body.scrollTop</div></div><div><br/></div><div><span style="font-weight: bold;">43、可视区的大小</span></div><ul><li><div>innerXXX（不兼容ie）</div></li><ul><li><div>window.innerHeight  可视区高度，包含滚动条宽度</div></li><li><div>window.innerWidth  可视区宽度，包含滚动条宽度</div></li></ul><li><div>document.documentElement.clientXXX(兼容ie)</div></li><ul><li><div>document.documentElement.clientWidth  可视区宽度，不包含滚动条宽度</div></li><li><div>document.documentElement.clientHeight  可视区高度，不包含滚动条宽度</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">44、节点的种类有几种，分别是什么？</span></div><ul><li><div>元素节点：nodeType ===1;</div></li><li><div>文本节点：nodeType ===3;</div></li><li><div>属性节点：nodeType ===2;</div></li></ul><div><br/></div><div><span style="font-weight: bold;">45、innerHTML和outerHTML的区别</span></div><ul><li><div>innerHTML(元素内包含的内容）</div></li><li><div>outerHTML(自己以及元素内的内容）</div></li></ul><div><br/></div><div><span style="font-weight: bold;">46、offsetWidth offsetHeight和clientWidth clientHeight的区别</span></div><ul><li><div>offsetWidth （content宽度+padding宽度+border宽度）</div></li><li><div>offsetHeight（content高度+padding高度+border高度）</div></li><li><div>clientWidth（content宽度+padding宽度）</div></li><li><div>clientHeight（content高度+padding高度）</div></li></ul><div><br/></div><div><span style="font-weight: bold;">47、闭包的好处</span></div><ul><li><div>希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)</div></li><li><div>避免全局变量的污染</div></li><li><div>私有成员的存在</div></li><li><div>安全性提高</div></li></ul><div><br/></div><div><span style="font-weight: bold;">48、js 实现一个函数对javascript中json 对象进行克隆</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var oldObject =&quot;sdf&quot;;</div><div>var newObject = JSON.parse(JSON.stringify(oldObject));</div><div>console.log(newObject);</div><div><br/></div><div>或者</div><div><br/></div><div>var a = 'dddd';</div><div>function cp(a){</div><div>    return JSON.parse(JSON.stringify(a))</div><div>}</div><div>console.log(cp(a));</div></div><div><br/></div><div><span style="font-weight: bold;">49、js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function(url, fn) {</div><div>    var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据</div><div>    obj.open('GET', url, true);</div><div>    obj.onreadystatechange = function() {</div><div>        if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) {</div><div>            loading.style.display = &quot;none&quot;</div><div>        } else {</div><div>            alert(&quot;不能点击,哈哈哈!&quot;);</div><div>        }</div><div>    };</div><div>    obj.send(null);</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">50、js 实现一个函数 获得url参数的值</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function getQueryString(name) {</div><div>    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);</div><div>    var r = window.location.search.substr(1).match(reg);</div><div>    if (r != null) return unescape(r[2]); </div><div>    return null;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">51、请用js计算1-10000中出现的0 的次数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>new Array(10000).fill('').map((_, index) =&gt; index + 1).filter(item =&gt; /0/.test(item)).reduce((count, item) =&gt; { return count + (String(item).match(/0/g) || []).length}, 0)</div></div><div><br/></div><div><span style="font-weight: bold;">52、降维数组</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var arr=[[1,2],[3,4]];</div><div>function Jw(obj){</div><div>    return Array.prototype.concat.apply([],obj);</div><div>}</div><div>Jw(arr);</div></div><div><br/></div><div><span style="font-weight: bold;">53、将url的查询参数解析成字典对象</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function getQueryObject(url) {</div><div>    url = url == null ? window.location.href : url;</div><div>    var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1);</div><div>    var obj = {};</div><div>    var reg = /([?&amp;=]+)=([?&amp;=]*)/g;</div><div>    search.replace(reg, function (rs, 2) {</div><div>        var name = decodeURIComponent(2);</div><div>        val = String(val);</div><div>        obj[name] = val;</div><div>        return rs;</div><div>    });</div><div>    return obj;</div><div>}</div></div><div><span style="font-weight: bold;">54、判断一个字符串中出现次数最多的字符，统计这个次数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var str = 'asdfssaaasasasasaa';</div><div>var json = {};</div><div>for (var i = 0; i &lt; str.length; i++) {</div><div>    if(!json[str.charAt(i)]){</div><div>        json[str.charAt(i)] = 1;</div><div>    }else{</div><div>        json[str.charAt(i)]++;</div><div>    }</div><div>};</div><div>var iMax = 0;</div><div>var iIndex = '';</div><div>for(var i in json){</div><div>    if(json[i]&gt;iMax){</div><div>        iMax = json[i];</div><div>        iIndex = i;</div><div>    }</div><div>}</div><div>alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');</div></div><div><br/></div><div><span style="font-weight: bold;">55、编写一个方法 求一个字符串的字节长度</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//假设一个中文占两个字节</div><div>var str = '22两是';</div><div>alert(getStrlen(str))</div><div>function getStrlen(str){</div><div>    var json = {len:0};</div><div>    var re = /[\u4e00-\u9fa5]/;</div><div>    for (var i = 0; i &lt; str.length; i++) {</div><div>        if(re.test(str.charAt(i))){</div><div>            json['len']++;</div><div>        }</div><div>    };</div><div>    return json['len']+str.length;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">56、编写一个方法 去掉一个数组的重复元素</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var arr = [1,2,3,1,43,12,12,1];</div><div>var json = {};</div><div>var arr2 = [];</div><div>for (var i = 0; i &lt; arr.length; i++) {</div><div>    if(!json[arr[i]]){</div><div>        json[arr[i]] = true;</div><div>    }else{</div><div>        json[arr[i]] = false;</div><div>    }</div><div>    if(json[arr[i]]){</div><div>        arr2.push(arr[i]);</div><div>    }</div><div>};</div><div>for (var i = 0; i &lt; arr.length; i++) {</div><div>    if(!aa(arr[i], arr2)){</div><div>        arr2.push(arr[i])</div><div>    }</div><div>};</div><div>function aa(obj, arr){</div><div>    for (var i = 0; i &lt; arr.length; i++) {</div><div>        if(arr[i] == obj) return true;</div><div>    else return false;</div><div>    };</div><div>}</div><div>alert(arr2)</div></div><div><br/></div><div><span style="font-weight: bold;">57、写出3个使用this的典型应用</span></div><ul><li><div>事件：如onclick this-&gt;发生事件的对象</div></li><li><div>构造函数：this-&gt;new 出来的object</div></li><li><div>call/apply：改变this</div></li></ul><div><br/></div><div><span style="font-weight: bold;">58、如何深度克隆</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var arr = [1,2,43];</div><div>var json = {a:6,b:4,c:[1,2,3]};</div><div>var str = 'sdfsdf';</div><div>var json2 = clone(json);</div><div>alert(json['c'])</div><div><br/></div><div>function clone(obj){</div><div>    var oNew = new obj.constructor(obj.valueOf());</div><div>    if(obj.constructor == Object){</div><div>        for(var i in obj){</div><div>            oNew[i] = obj[i];</div><div>            if(typeof(oNew[i]) == 'object'){</div><div>                clone(oNew[i]);</div><div>            }</div><div>        }</div><div>    }</div><div>    return oNew;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">59、JavaScript中如何检测一个变量是一个String类型？请写出函数实现</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>typeof(obj) == 'string'</div><div>obj.constructor == String;</div></div><div><br/></div><div><span style="font-weight: bold;">60、网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var oDate = new Date();</div><div>var oYear = oDate.getFullYear();</div><div>var oNewDate = new Date();</div><div>oNewDate.setFullYear(oYear, 11, 31, 23, 59, 59);</div><div>var iTime = oNewDate.getTime()-oDate.getTime();</div><div>var iS = iTime / 1000;</div><div>var iM = oNewDate.getMonth()-oDate.getMonth();</div><div>var iDate = iS</div></div><div><br/></div><div><span style="font-weight: bold;">61、为什么利用多个域名来存储网站资源会更有效？</span></div><div>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站</div><div><br/></div><div><span style="font-weight: bold;">62、请说出三种减低页面加载时间的方法</span></div><ul><li><div>压缩css、js文件</div></li><li><div>合并js、css文件，减少http请求</div></li><li><div>外部js、css文件放在最底下</div></li><li><div>减少dom操作，尽可能用变量替代不必要的dom操作</div></li></ul><div><br/></div><div><span style="font-weight: bold;">63、闭包</span></div><div>子函数能被外部调用到，则该作用连上的所有变量都会被保存下来</div><div><br/></div><div><span style="font-weight: bold;">64、请解释什么是Javascript的模块模式，并举出实用实例</span></div><ul><li><div>js模块化mvc（数据层、表现层、控制层）</div></li><li><div>seajs</div></li><li><div>命名空间</div></li></ul><div><br/></div><div><span style="font-weight: bold;">65、你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</span></div><div>对内：模块模式</div><div>对外：继承</div><div><br/></div><div><span style="font-weight: bold;">66、你如何优化自己的代码？</span></div><ul><li><div>代码重用</div></li><li><div>避免全局变量（命名空间，封闭空间，模块化mvc..）</div></li><li><div>拆分函数避免函数过于臃肿</div></li><li><div>注释</div></li></ul><div><br/></div><div><span style="font-weight: bold;">67、你能解释一下JavaScript中的继承是如何工作的吗？</span></div><div>子构造函数中执行父构造函数，并用 call\apply 改变 this</div><div>克隆父构造函数原型上的方法</div><div><br/></div><div><span style="font-weight: bold;">68、请尽可能详尽的解释AJAX的工作原理</span></div><ul><li><div>创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）</div></li><li><div>判断数据传输方式(GET/POST)</div></li><li><div>打开链接 open()</div></li><li><div>发送 send()</div></li><li><div>当ajax对象完成第四步（onreadystatechange）数据接收完成</div></li><li><div>判断http响应状态（status）200-300之间或者304（缓存）执行回调函数</div></li></ul><div><br/></div><div><span style="font-weight: bold;">69、最简单的一道题</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var a = 2, b = 3;</div><div>var c = a+++b; // c = 5</div></div><div><br/></div><div><span style="font-weight: bold;">70、var和function的预解析问题,以及变量和function的先后顺序的问题</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 以下代码执行输出结果是什么</div><div>function b () {</div><div>    console.log(a);</div><div>    var a = 10;</div><div>    function a() {};</div><div>    a = 100;</div><div>    console.log(a);</div><div>}</div><div>b();</div><div><br/></div><div>function c () {</div><div>    console.log(a);</div><div>    function a() {};</div><div>    var a = 10;</div><div>    a = 100;</div><div>    console.log(a);</div><div>}</div><div>c();</div><div><br/></div><div>(function d (num) {</div><div>    console.log(num);</div><div>    var num = 10;</div><div>}(100))</div><div><br/></div><div>(function e (num) {</div><div>    console.log(num);</div><div>    var num = 10;</div><div>    function num () {};</div><div>}(100))</div><div><br/></div><div>(function f (num) {</div><div>    function num () {};</div><div>    console.log(num);</div><div>    var num =10</div><div>    console.log(num);</div><div>}(100))</div><div><br/></div><div>//仍然是预解析(在与解析过程中还要考虑一下当前变量的作用于)</div><div>function m () {</div><div>    console.log(a1); // underfined</div><div>    console.log(a2); // underfined</div><div>    console.log(b1); // underfined</div><div>    console.log(b2); // underfined</div><div>    if(false) {</div><div>        function b1 (){};</div><div>        var a1 = 10;</div><div>    }</div><div>    if(true) {</div><div>        function b2 (){};</div><div>        var a2 = 10;</div><div>    }</div><div>    console.log(a1); // underfined</div><div>    console.log(a2); // 10</div><div>    console.log(b1); // underfined</div><div>    console.log(b2); // function</div><div>}</div><div>m();</div><div><br/></div><div>function n() {</div><div>    if(2&gt;1) {</div><div>        arr = 10;</div><div>        brr = 10;</div><div>        let arr;</div><div>        var brr;</div><div>        console.log(arr);</div><div>        console.log(brr);</div><div>    }</div><div>}</div><div>n(); // ReferenceError</div></div><div><br/></div><div><span style="font-weight: bold;">71、dom事件委托什么原理，有什么优缺点</span></div><div><span style="font-weight: bold;">原理：</span>事件冒泡机制</div><div><span style="font-weight: bold;">优点：</span></div><ul><li><div>可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。</div></li><li><div>可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</div></li></ul><div><span style="font-weight: bold;">缺点：</span></div><ul><li><div>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件</div></li></ul><div><br/></div><div><span style="font-weight: bold;">72、http的cache机制，以及200状态下怎么实现 from cache（表示接触最多的就是304的from cache）（用于优化，没有接触过，需要理解）</span></div><div><span style="font-weight: bold;">定义：</span>浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</div><div><br/></div><div><span style="font-weight: bold;">cache的作用：</span></div><ul><li><div>减少延迟，让你的网站更快，提高用户体验。</div></li><li><div>避免网络拥塞，减少请求量，减少输出带宽。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">实现手段：</span></div><ul><li><div>Cache-Control中的max-age是实现内容cache的主要手段，共有3种常用策略：</div></li><li><div>max-age和Last-Modified（If-Modified-Since）的组合</div></li><li><div>仅max-age</div></li><li><div>max-age和ETag的组合。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">其它：</span></div><div>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略</div><div>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存</div><div><br/></div><div><span style="font-weight: bold;">73、一个原型链继承的问题</span></div><div>// 有一个构造函数A，写一个函数B，继承A</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function A (num) {</div><div>    this.titileName = num;</div><div>}</div><div><br/></div><div>A.prototype = {</div><div>    fn1: function () {},</div><div>    fn2: function () {}</div><div>}</div></div><div>这个问题的关注点是B继承的A的静态属性，同时B的原型链中不存在A实例的titleName属性</div><div><br/></div><div><span style="font-weight: bold;">74、虚拟dom</span></div><div><span style="font-weight: bold;">dom本质：</span>浏览器的概念，用js对象来表示页面上的元素，并提供了操作dom对象的API</div><div><br/></div><div><span style="font-weight: bold;">DOM树的概念：</span></div><div>一个网页的呈现过程：</div><ul><li><div>浏览器请求服务器获取页面HTML代码</div></li><li><div>浏览器在内存中，解析dom结构，并在浏览器内存中渲染出一颗dom树</div></li><li><div>浏览器把dom树，呈现在页面上</div></li></ul><div><br/></div><div><span style="font-weight: bold;">虚拟dom：</span>指的是用js对象的形式，来模拟页面上Dom嵌套关系。（以js对象的形式存在的）</div><div><span style="font-weight: bold;">如：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;div id=&quot;name&quot; title= &quot;name&quot;&gt;</div><div>    ccccc</div><div>    &lt;p&gt;dhhhh&lt;/p&gt;</div><div>&lt;/div&gt;</div><div><br/></div><div>//文本也属于子节点</div></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="color: rgb(33, 37, 41); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-variant-caps: normal; font-variant-ligatures: normal; font-size: 10pt; font-weight: bold;">上面的 HTML 转换为虚拟 DOM 如下：</span></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var div = {</div><div>    tagName: 'div',</div><div>    attrs:{</div><div>        id: &quot;name&quot; ，</div><div>        title: &quot;name&quot;   </div><div>    },</div><div>    childrens: [</div><div>        'ccccc',</div><div>        {</div><div>            tagName: 'p',</div><div>            attrs:{},</div><div>            childrens: [</div><div>                'dhhhh',</div><div>            ]</div><div>        }</div><div>    ]</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">其它示例：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const HelloWorld = {</div><div>    nodeName:'div',</div><div>    attrs:{</div><div>        className:'',</div><div>    },</div><div>    css:{</div><div>        width: '100px',</div><div>        height: '40px',</div><div>        color: 'green'</div><div>    },</div><div>    events:{</div><div>        onclick:()=&gt;{ console.log('Hello virtual DOM') }</div><div>    },</div><div>    childrens:[</div><div>        {</div><div>            nodeName:'text',</div><div>            attrs:{</div><div>                innerText:'HelloWorld',</div><div>            },</div><div>        }</div><div>    ]</div><div>}</div><div><br/></div><div>解析：</div><div>function render(vNode) {</div><div>    // 创建dom</div><div>    const dom = document.createElement(vNode.nodeName)</div><div>    const { attrs, css, events, childrens } = vNode</div><div><br/></div><div>    // 添加属性</div><div>    for(const attrName in attrs){</div><div>        dom[attrName] = attrs[attrName]</div><div>    }</div><div><br/></div><div>    // 添加行内样式</div><div>    for(const attrName in css){</div><div>        dom.style[attrName] = css[attrName]</div><div>    }</div><div><br/></div><div>    // 添加事件</div><div>    for(const eventName in events){</div><div>        dom[eventName] = events[eventName]</div><div>    }</div><div><br/></div><div>    if(childrens){</div><div>        for(const children of childrens) {</div><div>            // 生成子节点</div><div>            const childrenNode = render(children)</div><div>            // 绑定子节点</div><div>            dom.append(childrenNode)</div><div>        }</div><div>    }</div><div><br/></div><div>    return dom</div><div>}</div><div><br/></div><div>使用：</div><div>const dom = render(HelloWorld)</div><div>document.body.append(dom)</div></div><div><br/></div><div><span style="font-weight: bold;">dom和虚拟dom的区别：</span></div><ul><li><div>dom：浏览器中提供的概念，用JS对象表示页面上的元素，并提供了操作元素的api</div></li><li><div>虚拟dom：框架中的概念，是开发框架的程序猿手动用js对象来模拟dom元素和嵌套关系</div></li><ul><li><div>本质： 用就是对象来模拟dom元素和嵌套关系</div></li><li><div>目的： 实现页面元素的高效更新</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Diff算法：</span></div><ul><li><div>tree diff:新旧两棵dom树，dom层逐级对比完毕，则所有需要被按需更新的元素，必然能够找到</div></li><li><div>component diff:在进行tree diff的时候，每一层中组件级别的对比，叫做component diff</div></li><ul><li><div>如果对比前后组件类型相同，则暂时认为此组件不需要被更新</div></li><li><div>如果对比前后组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上</div></li></ul><li><div>element diff 在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比</div></li></ul><div><br/></div><div><span style="font-weight: bold;">75、js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</span></div><ul><li><div>基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String、symbol</div></li><li><div>引用数据类型（对象）：Object （Array，Date，RegExp，Function）</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function gettype(nm){</div><div>    return Object.prototype.toString.call(nm);</div><div>}</div><div><br/></div><div>document.write(gettype(123))  //[object Number]</div></div><div><br/></div><div><span style="font-weight: bold;">76、vue双向数据绑定的原理是什么</span></div><div>首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription)，在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）数组的实现与对象不同。同时运用观察者模式实现wather，用户数据和view视图的更新</div><div><br/></div><div><span style="font-weight: bold;">77、react和vue比较来说有什么区别</span></div><ul><li><div>component层面，web component和virtual dom</div></li><li><div>数据绑定（vue双向，react的单向）等好多</div></li><li><div>计算属性 vue 有，提供方便；而 react 不行</div></li><li><div>vue 可以 watch 一个数据项；而 react 不行</div></li><li><div>vue 由于提供的 direct 特别是预置的 directive 因为场景场景开发更容易；react 没有</div></li><li><div>生命周期函数名太长 directive</div></li></ul><div><br/></div><div><span style="font-weight: bold;">78、git使用过程中，如果你在开发着业务，突然另一个分支有一个bug要改，你怎么办</span></div><div>git stash //将本次修改存到暂存区（紧急切换分支时）</div><div>git stash pop //将所有暂存区的内容取出来</div><div><br/></div><div><span style="font-weight: bold;">79、执行下面代码</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var a = {};</div><div>var b = {key: 'b'};</div><div>var c = {key: 'c'};</div><div>var d = [3,5,6];</div><div><br/></div><div>a[b] = 123;</div><div>a[c] = 345;</div><div>a[d] = 333;</div><div>console.log(a[b]); // 345</div><div>console.log(a[c]); // 345</div><div>console.log(a[d]); // 33390</div><div><br/></div><div>var R = (function() {</div><div>    var u = {a:1,b:2};</div><div>    var r = {</div><div>        fn: function(k) {</div><div>            return u[k];</div><div>        }</div><div>    }</div><div>    return r;</div><div>}());</div><div><br/></div><div>R.fn('a'); // 1</div></div><div>上述代码中如何获取匿名函数中的u</div><div><br/></div><div><span style="font-weight: bold;">80、不适用循环语句（包括map、forEach方法）实现一个100长度的数组，索引值和值相同的数组[0,1,2,3,4,5........99]</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var arr = new Array(100);</div><div><br/></div><div>//方法1</div><div>[...arr.keys()];</div><div><br/></div><div>//方法二</div><div>Array.from(arr.keys());</div><div><br/></div><div>//方法三</div><div>Array.from({length: 100});</div><div><br/></div><div>// 方法四 借助stringvar</div><div>arr1 = new Array(101);</div><div>var str = arr1.join('1,');</div><div>str = str.replace(/(1\,)/g, function ($0, $1, index) {</div><div>    var start = '' + Math.ceil(index/2);</div><div>    if(index &lt; str.length - 2) {</div><div>        start += ','</div><div>    }</div><div>    return start;</div><div>});</div><div>return str.split(',');</div><div><br/></div><div>// 方法五（函数式，参考网络）</div><div>function reduce(arr, val) {</div><div>    if(Object.prototype.toString.apply(val)){</div><div>        return;</div><div>    }</div><div>    if(val &gt;= 100) {</div><div>        return arr;</div><div>    }</div><div>    arr.push(val);</div><div>    return reduce(arr, val+1);</div><div>}</div><div>var res = reduce([], 0)</div></div><div><br/></div><div><span style="font-weight: bold;">81、下面语句执行结果输出</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var a = function (val, index) {</div><div>    console.log(index);</div><div>    return {</div><div>        fn: function (name) {</div><div>            return a(name, val);</div><div>        }</div><div>    }</div><div>}</div><div>var b = a(0); // underfined</div><div><br/></div><div>b.fn(1); // 0</div><div>b.fn(2); // 0</div><div>b.fn(3); // 0</div></div><div><br/></div><div><span style="font-weight: bold;">82、科普</span></div><ul><li><div>dom节点的根节点是不是body</div></li></ul><div>不是，dom节点的根节点是html(包含head和body，head中分为meta、title等。body又分为一组)</div><div><br/></div><ul><li><div>dom元素都会有offsetParent吗</div></li></ul><div>offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位，则offsetParent属性的取值为根元素(在标准兼容模式下为html元素；在怪异呈现模式下为body元素)的引用。 当容器元素的style.display 被设置为 &quot;none&quot;时（译注：IE和Opera除外），offsetParent属性 返回 null</div><div><br/></div><ul><li><div>[1,3,5]转译成字符串是什么</div></li></ul><div>'1,3,5'（调用toString方法，生成该字符串 [1,3,5].toString() ）</div><div><br/></div><ul><li><div>li标签的祖级元素可以为li，父级元素也可以为li</div></li></ul><div>错误</div><div><br/></div><div><span style="font-weight: bold;">83、http协议属于七层协议中的哪一层，下一层是什么</span></div><div>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</div><div>tcp属于传输层；http属于应用层；表现层</div><div><br/></div><div><span style="font-weight: bold;">84、js垃圾回收机制知道哪些，v8引擎使用的哪一种js的两种回收机制</span></div><ul><li><div>标记清除（mark and sweep）</div></li><li><div>引用计数（reference counting）javascript与V8引擎</div></li></ul><div><br/></div><div><span style="font-weight: bold;">85、垃圾回收机制的好处和坏处</span></div><div><span style="font-weight: bold;">好处：</span>大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题</div><div><span style="font-weight: bold;">坏处：</span>自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理</div><div><br/></div><div><span style="font-weight: bold;">86、 作用域什么时候生成的？</span></div><div>页面加载--&gt;创建window全局对象，并生成全局作用域--&gt;然后生成执行上下文，预解析变量(变量提升)，生成全局变量对象；</div><div><br/></div><div><span style="font-weight: bold;">87、websocket长连接原理是什么含义</span></div><div>相对于HTTP这种非持久的协议来说，Websocket是一个持久化的协议</div><div><span style="font-weight: bold;">原理：</span></div><div>类似长轮循长连接，发送一次请求，源源不断的得到信息</div><div><br/></div><div><span style="font-weight: bold;">88、讲一下事件循环机制</span></div><ul><li><div>执行上下文(Execution context)</div></li><li><div>函数调用栈(call stack)</div></li><li><div>队列数据结构(queue)</div></li></ul><div><br/></div><div><span style="font-weight: bold;">89、理解web安全吗？都有哪几种，介绍以及如何预防</span></div><ul><li><div>XSS，也就是跨站脚本注入</div></li><ul><li><div>攻击方法：</div></li><ul><li><div>手动攻击:</div></li><ul><li><div>编写注入脚本，比如”/&gt;&lt;script&gt;alert(document.cookie());&lt;/script&gt;&lt;!--等，</div></li><li><div>手动测试目标网站上有的input, textarea等所有可能输入文本信息的区域</div></li></ul></ul><li><div>自动攻击</div></li><ul><li><div>利用工具扫描目标网站所有的网页并自动测试写好的注入脚本，比如：Burpsuite等</div></li></ul><li><div>防御方法：</div></li><ul><li><div>将cookie等敏感信息设置为httponly，禁止Javascript通过document.cookie获得</div></li><li><div>对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式</div></li><li><div>净化和过滤掉不必要的html标签，比如：&lt;iframe&gt;, alt,&lt;script&gt; 等</div></li><li><div>净化和过滤掉不必要的Javascript的事件标签，比如：onclick, onfocus等</div></li><li><div>转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符</div></li><li><div>设置浏览器的安全设置来防范典型的XSS注入</div></li></ul></ul></ul><div><br/></div><ul><li><div>SQL注入</div></li><ul><li><div>攻击方法：</div></li><ul><li><div>编写恶意字符串，比如‘ or 1=1--等</div></li><li><div>手动测试目标网站上所有涉及数据库操作的地方</div></li></ul><li><div>防御方法：</div></li><ul><li><div>禁止目标网站利用动态拼接字符串的方式访问数据库</div></li><li><div>减少不必要的数据库抛出的错误信息</div></li><li><div>对数据库的操作赋予严格的权限控制</div></li><li><div>净化和过滤掉不必要的SQL保留字，比如：where, or, exec 等</div></li><li><div>转义单引号，上引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符</div></li></ul></ul></ul><div><br/></div><ul><li><div>CSRF（跨站请求伪造，就是攻击者冒用用户的名义，向目标站点发送请求）</div></li><ul><li><div>防范方法：</div></li><ul><li><div>在客户端进行cookie的hashing，并在服务端进行hash认证</div></li><li><div>提交请求是需要填写验证码</div></li><li><div>使用One-Time Tokens为不同的表单创建不同的伪随机值</div></li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">90、sessionStorage和localstorage能跨域拿到吗？比如我在</span><a href="http://www.baidu.com/" style="font-weight: bold;">www.baidu.com</a><span style="font-weight: bold;">设置的值能在</span><a href="http://m.baidu.com/" style="font-weight: bold;">m.baidu.com</a><span style="font-weight: bold;">能拿到吗？为什么</span></div><div>不能。<span style="font-weight: bold;">sessionStorage和</span>localStorage会跟cookie一样受到跨域的限制，会被document.domain影响</div><div><br/></div><div><span style="font-weight: bold;">91、localstorage不能手动删除的时候，什么时候过期？</span><span style="font-weight: bold;">sessionStorage呢？</span></div><ul><li><div>除非被清除，否则永久保存，不过 localstorage.clear() 可清除</div></li><li><div>sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除</div></li></ul><div><br/></div><div><span style="font-weight: bold;">92、封装一个函数，参数是定时器的时间，.then执行回调函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function sleep (time) {</div><div>    return new Promise((resolve) =&gt; setTimeout(resolve, time));</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">93、一行代码实现数组去重？</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[...new Set([1,2,3,1,'a',1,'a'])]</div><div>//[1, 2, 3, &quot;a&quot;]</div></div><div><br/></div><div><span style="font-weight: bold;">94、使用addEventListener点击li弹出内容，并且动态添加li之后有效</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;ul&gt;</div><div>    &lt;li&gt;1&lt;/li&gt;</div><div>    &lt;li&gt;2&lt;/li&gt;</div><div>    &lt;li&gt;3&lt;/li&gt;</div><div>    &lt;li&gt;4&lt;/li&gt;</div><div>&lt;/ul&gt;</div><div><br/></div><div>var ulNode = document.getElementById(&quot;ul&quot;);</div><div>ulNode.addEventListener('click', function (e) {</div><div>    if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == &quot;LI&quot;) {</div><div>        alert(e.target.innerHTML);</div><div>    }</div><div>}, false);</div></div><div><br/></div><div><span style="font-weight: bold;">95、怎么判断两个对象相等</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>JSON.stringify({name: 'Tom'}) == JSON.stringify({name: 'Tom'}); //true</div></div><div><br/></div><div><span style="font-weight: bold;">96、Vue router 跳转和 location.href 有什么区别？</span></div><ul><li><div>router 是 hash 改变</div></li><li><div>location.href 是页面跳转，刷新页面</div></li></ul><div><br/></div><div><span style="font-weight: bold;">97、js bind 实现机制？手写一个 bind 方法？</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function bind(fn, context){</div><div>    return function (){</div><div>        return fn.apply(context, arguments);</div><div>    }</div><div>}</div><div><br/></div><div>// 柯理化函数思想</div><div>Function.prototype.bind = function (context) {</div><div>    var args = Array.prototype.slice.call(arguments, 1);</div><div>    var _this = this;</div><div>    return function () {</div><div>        var thisArgs = [].slice.call(arguments);</div><div>        return _this.apply(context, args.concat(thisArgs))</div><div>    };</div><div>}</div><div><br/></div><div>// ES6写法</div><div>Function.prototype.bind = function(context, ...res) {</div><div>    let self = this</div><div>    return function(...arg) {</div><div>        return self.apply(context, [...res,...arg])</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">98、多个函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var a = (function(){</div><div>        return '1';</div><div>    }, function(){</div><div>        return 1;</div><div>})();</div><div>console.log(typeof a); //number</div></div><div><br/></div><div><span style="font-weight: bold;">99、proto、prototype、Object.getPrototypeOf()</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>__proto__是指内部原型，和 Object.getPrototypeOf() 结果等价</div><div><br/></div><div>function f(){}</div><div><br/></div><div>f.__proto__ === Object.getPrototypeOf(f); //true</div><div>f.prototype === Object.getPrototypeOf(f); //false</div></div><div><br/></div><div><span style="font-weight: bold;">100、setTimeout 和 setInterval 细谈</span></div><ul><li><div>setTimeout 是在一定时间过后将函数添加至执行队列，执行时间 = 延迟时间 + 之前函数代码执行时间 + 执行函数时间</div></li><li><div>setInterval<span style="font-weight: bold;"> </span>是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作</div></li></ul><div><span style="font-weight: bold;">注意：</span>如果需要控制前后执行顺序，最好使用 setTimeout 模拟 setInterval</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var time = 400, times = 0, max = 10;</div><div>function func(){</div><div>    times++;</div><div>    if(times &lt; max){</div><div>    //code here</div><div>        setTimeout(func, time);</div><div>    } else {</div><div>        console.log(&quot;finished&quot;);</div><div>    }</div><div>}</div><div>setTimeout(func, time);</div></div><div><br/></div><div><span style="font-weight: bold;">101、判断多图片加载完毕</span></div><div>注：用jQueryObject.ready()只能判断dom结构加载完毕</div><div><br/></div><div><span style="font-weight: bold;">方法1：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var counter = 0;</div><div>var queryInterval = 30; //msvar pics = document.getElementsByClassName(&quot;pics&quot;);</div><div><br/></div><div>function singleQuery(i){</div><div>    if(pics[i].complete){</div><div>        counter++;</div><div>        console.log(i + &quot; is loaded&quot;);</div><div>    } else {</div><div>        setTimeout(singleQuery, queryInterval, i);</div><div>    }</div><div>}</div><div><br/></div><div>function allQuery(callback){</div><div>    if(counter &lt; pics.length){</div><div>        console.log(&quot;current number of loaded pics: &quot; + counter);</div><div>        setTimeout(allQuery, queryInterval, callback);</div><div>    } else {</div><div>        console.log(&quot;All pics are loaded.&quot;);</div><div>        callback();</div><div>    }</div><div>}</div><div><br/></div><div>for(var i = 0; i &lt; pics.length; i++){</div><div>    setTimeout(singleQuery, queryInterval, i);</div><div>}</div><div><br/></div><div>setTimeout(allQuery, queryInterval, callback);</div><div><br/></div><div>//主要也是采用setTimeout模拟轮询，判断方式是img标签dom的complete属性（布尔值），缺点是定时器太多。</div></div><div><br/></div><div><span style="font-weight: bold;">方法2：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var counter = 0, queryInterval = 50;</div><div>var pics = document.getElementsByClassName(&quot;pics&quot;);</div><div>for(var i = 0; i &lt; pics.length; i++){</div><div>    pics[i].onload = function(){</div><div>        counter++;</div><div>        console.log(this.id + &quot; is loaded&quot;);</div><div>    }</div><div>}</div><div><br/></div><div>function queryPictures(callback){</div><div>    if(counter &lt; pics.length){</div><div>        console.log(&quot;current number of loaded pics: &quot; + counter);</div><div>        setTimeout(queryPictures, queryInterval, callback);</div><div>    } else {</div><div>        console.log(&quot;All pics are loaded&quot;);</div><div>        callback();</div><div>    }</div><div>}</div><div>setTimeout(queryPictures, queryInterval, callback);</div><div><br/></div><div>//利用onload绑定图片加载成功后的回调，通过计数器判断是否加载完毕。</div></div><div><br/></div><div><span style="font-weight: bold;">102、object.propertyIsEnumerable(</span><span style="font-size: 16px; background: rgb(238, 238, 238); position: relative; overflow: auto; tab-size: 4; hyphens: none; box-sizing: border-box; width: 1014px; max-width: 100%; white-space: pre-wrap; letter-spacing: -0.04448px; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; border-top: 0px; border-bottom: 0px; border-left: 0px; border-right-style: initial; border-right-color: initial; border-image: initial; border-radius: 2px; overflow-wrap: break-word; border-right-width: 0px !important; direction: ltr !important; color: rgb(51, 51, 51); font-family: consolas, &quot;Liberation Mono&quot;, courier, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">prop</span><span style="font-weight: bold;">)</span></div><div>此方法返回一个布尔值，表示指定的属性是否可枚举</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const object1 = {};</div><div>const array1 = [];</div><div>object1.property1 = 42;</div><div>array1[0] = 42;</div><div><br/></div><div>console.log(object1.propertyIsEnumerable('property1'));</div><div>// expected output: true</div><div><br/></div><div>console.log(array1.propertyIsEnumerable(0));</div><div>// expected output: true</div><div><br/></div><div>console.log(array1.propertyIsEnumerable('length'));</div><div>// expected output: false</div></div><div><br/></div><div><span style="font-weight: bold;">103、判断数组</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function isArray(arr){</div><div>    return Object.prototype.toString.call(arr) === '[Object Array]';</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">104、git fetch &amp;&amp; git pull</span></div><ul><li><div>git pull自动完成了fetch最新远程版本，并且和本地进行merge</div></li><li><div>git fetch获得远程分支，要继续手动merge合并</div></li></ul><div><br/></div><div><span style="font-weight: bold;">105、跨域</span></div><div><span style="font-weight: bold;">只要协议、域名、端口有不同，则视为不同的域。（域名和域名对应的IP也是跨域）</span></div><div><br/></div><div><span style="font-weight: bold;">解决跨域：</span></div><ul><li><div>CORS: Cross-Origin Resource Sharing基于服务器支持的跨域，服务器设置Access-Control-Allow-Origin响应头，浏览器可允许跨域</div></li><li><div>设置domain，能从子域设到主域，如<a href="http://a.b.c.com/">a.b.c.com</a>—&gt;<a href="http://b.c.com/">b.c.com</a>—&gt;c.com</div></li><ul><li><div>具体情况：在页面中用iframe打开了另一个页面（前提：两个页面主域是相同的）利用frameElement.contentWindow.document.domain设置frame子页面的主域，document.domain设置主页面的主域，之后就能互相获取dom中的数据。</div></li><li><div>缺点：只能用于不同子域间的交互。</div></li></ul><li><div>例如拥有src属性的img标签，每次改变src属性，都会发起http请求。</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var img = new Image();</div><div>img.onload = function(){</div><div>    //code here</div><div>};</div><div>img.onerror = function(){</div><div>    //code here</div><div>};</div><div>img.src = &quot;http://server.com/data?query=3&quot;;</div></div><ul><ul><li><div>缺点是只能使用GET请求，不能获取数据，一般用于提交统计信息什么的。script、link、iframe只有在添加到DOM中才会发起请求</div></li></ul><li><div>HTML5 postMessage（支持IE8+和主流浏览器，写法也简单..）</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//source: http://test.org:4000</div><div>//get the window object of target origin</div><div>var win = window.open(&quot;http://target.com&quot;);</div><div><br/></div><div>//or this, when a frame is used</div><div>var win = document.getElementById(&quot;targetId&quot;).contentWindow;</div><div>win.postMessage(&quot;data here&quot;, &quot;http://target.com/rest&quot;);</div><div><br/></div><div>//target: http://target.com/tinyfunction </div><div>handleMessage(event){</div><div>    if(event.orgin!=&quot;http://test.org:4000&quot;)</div><div>    return;</div><div>    var data = event.data;</div><div>    //code here</div><div>    //event.source is window.opener</div><div>    event.source.postMessage(&quot;response data here&quot;, event.origin);</div><div>}</div><div>window.addEventListener(&quot;message&quot;, handleMessage, false);</div></div><ul><li><div>window.name</div></li></ul><div>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具</div><div>但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)</div><ul><li><div>jsonp 目前主流跨域方法</div></li></ul><div>调用其他域的脚本获取数据，前提是另一个域能知道回调函数名，这个可以通过请求发送给目标域。</div><div>直接写jQuery封的jsonp</div><div>$.getJSON(&quot;<a href="http://target.com/data?callback=callbackFunctionName">http://target.com/data?callback=callbackFunctionName</a>&quot;, function(data){});</div><div>$.getJSON会把获取的responseText转为json，如果url中有callback参数，数据会以script标签形式获取。</div><div><br/></div><div><span style="font-weight: bold;">106、闭包相关</span></div><ul><li><div>什么是闭包</div></li></ul><div>闭包是指有权访问另一个函数作用域中变量的函数</div><div><br/></div><ul><li><div>怎么创建闭包</div></li></ul><div>在函数内部嵌套使用函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function fn() {</div><div>    for (var i = 0; i &lt; 2; i++) {</div><div>        (function () {</div><div>            var variate = i;</div><div>            setTimeout(function () {</div><div>                console.log(&quot;setTimeout执行后:&quot;+variate);</div><div>            }, 1000);</div><div>        })();//闭包,立即执行函数,匿名函数</div><div>    }</div><div>    console.log(i);//2</div><div>    console.log(variate);//variate is not defined</div><div>}</div><div>fn();</div></div><div><br/></div><ul><li><div>为什么用闭包</div></li><ul><li><div>因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染</div></li><li><div>可以当做私有成员,弥补了因js语法带来的面向对象编程的不足</div></li><li><div>可以长久的在内存中保存一个自己想要保存的变量.闭包的缺点</div></li><li><div>可能导致内存占用过多,因为闭包携带了自身的函数作用域</div></li><li><div>闭包只能取得外部包含函数中得最后一个值</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">107、forEach和map的区别</span></div><div><span style="font-weight: bold;">相同点：</span></div><ul><li><div>都是循环遍历数组中的每一项</div></li><li><div>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）</div></li><li><div>匿名函数中的this都是指向window</div></li><li><div>只能遍历数组</div></li><li><div>都有兼容问题</div></li></ul><div><br/></div><div><span style="font-weight: bold;">不同点：</span></div><ul><li><div>map速度比foreach快</div></li><li><div>map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，</div></li><li><div>map因为返回数组所以可以链式操作，foreach不能</div></li></ul><div><br/></div><div><span style="font-weight: bold;">108、浅拷贝和深拷贝</span></div><ul><li><div>jQuery.extend 第一个参数可以是布尔值，用来设置是否深度拷贝的</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>jQuery.extend(true, { a : { a : &quot;a&quot; } }, { a : { b : &quot;b&quot; } } );</div><div>jQuery.extend( { a : { a : &quot;a&quot; } }, { a : { b : &quot;b&quot; } } );</div></div><ul><li><div>最简单的深拷贝</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>aa = JSON.parse( JSON.stringify(a) )</div></div><div><br/></div><div>浅复制---&gt;就是将一个对象的内存地址的“编号”复制给另一个对象</div><div>深复制---&gt;实现原理，先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子.....属性为基本数据类型</div><div><br/></div><div>总结，深复制理解两点：</div><ul><li><div>新开辟内存地址</div></li><li><div>递归来刨根复制</div></li></ul><div><br/></div><div><span style="font-weight: bold;">109、js加载位置区别优缺点</span></div><ul><li><div>html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行</div></li></ul><div>所以，大部分网上讨论是将script脚本放在&lt;body&gt;之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在&lt;body&gt;之前。其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效</div><ul><li><div>script放置位置的原则“页面效果实现类的js应该放在body之前，动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后”</div></li></ul></div><div><br/></div></span>
</div></body></html> 