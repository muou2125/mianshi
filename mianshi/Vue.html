<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="518"/>

<div>
<span><div><div style="text-align: start;"><span style="font-size: 12pt;"><b>1、什么是 vue 生命周期</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>简述：</b>Vue 实例从创建到销毁的过程，就是生命周期</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>详述：</b>从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>2、vue生命周期的作用是什么</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 16px;">在对应的生命周期内处理好对应的事务</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>3、vue生命周期总共有几个阶段</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">8个阶段：创建前/后、载入前/后、更新前/后、销毁前/后</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>4、第一次页面加载会触发哪几个钩子</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">第一次加载会触发 beforeCreate、created、beforeMount、mounted 4个钩子</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>5、DOM 渲染在哪个周期中就已经完成</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">DOM 渲染在 mounted 周期中就已经完成了</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>6、简述每个周期具体适合哪些场景</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>beforecreate : </b>可在此周期内处理页面loading事件，在加载实例时触发</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>created :</b> 初始化完成时的事件写在这里，如在此处理结束loading事件，异步请求也适宜在这里调用</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>mounted :</b> 挂载元素，获取到DOM节点 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>updated :</b> 如果对数据统一处理，在这里写上相应函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>beforeDestroy :</b> 可以做一个确认停止事件的确认框 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>nextTick :</b> 更新数据后立即操作dom</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>7、created和mounted的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>created：</b>在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>mounted：</b>在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>8、vue获取数据在哪个周期函数</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">一般 created/beforeMount/mounted 皆可</span></div><div style="text-align: start;"><span style="font-size: 12pt;">如：需要操作 DOM , 那肯定 mounted 周期内才能操作</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>9、如何让css样式只在当前组件起作用</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">在 style 标签中写入 <b>scoped </b>即可 </span></div><div style="text-align: start;"><span style="font-size: 12pt;">如：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;style scoped&gt;&lt;/style&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>10、v-if 和 v-show 区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>区别：</b>v-show 是 css 样式切换，v-if 是完整的销毁和重新创建</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>使用：</b>频繁切换时用 v-show，运行时较少改变时用 v-if。</span><span style="font-size: 12pt;">v-if是条件渲染，当false的时候不会渲染</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>注意：</b>v-show 不支持 &lt;template&gt; 元素，也不支持 v-else</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>11、v-if 和 v-for 的优先级</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐 v-if 和 v-for 同时使用</span></div><div style="text-align: start;"><font style="font-size: 12pt;">若有需求，一般在 v-for 外面增加一个 tempalet 在此上面做 v-if 的条件处理</font></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>12、$route 和 $router 的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">$router 是 VueRouter 的实例，在script标签中想要导航到不同的 URL，使用 $router.push 方法，返回上一个历史 history 用 $router.go(-1)</span></div><div style="text-align: start;"><span style="font-size: 12pt;">$route 为当前 router 跳转对象，里面可以获取当前路由的 name，path，query，parmas 等</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>13、vue的两个核心点</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>数据驱动：</b>ViewModel，保证数据和视图的一致性</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>组件系统：</b>应用类 UI 可以看作全部是由组件树构成的</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>14、vue几种常用的指令</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">v-for 、 v-if 、v-else、v-bind、v-on、v-show</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>15、vue常用的修饰符？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">.prevent：提交事件不再重载页面</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">.stop：阻止单击事件冒泡</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">.self：当事件发生在该元素本身而不是子元素的时候会触发</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">.capture：事件侦听，事件发生的时候会调用</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>16、v-on 可以绑定多个方法吗？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">可以</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">v-on绑定多个方法</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;p v-on=&quot;{ click: dbClick, mousemove: MouseClick }&quot;&gt;&lt;/p&gt;</div></div></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">一个事件绑定多个函数</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;p @click=&quot;one(),two()&quot;&gt;点击&lt;/p&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>17、vue 中 key 值的作用？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">key 的作用主要是为了高效的更新虚拟 DOM，</span><span style="font-size: 12pt;">管理可复用的元素</span><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b><br/></b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>18、vue 等单页面应用及其优缺点</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>优点：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>缺点：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">不支持低版本的浏览器，最低只支持到IE9</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">第一次加载首页耗时相对长一些</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">不可以使用浏览器的导航按钮需要自行实现前进、后退</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>19、怎么定义 vue-router 的动态路由？怎么获取 path 传过来的值</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">在 router 目录下的 index.js 文件中创建页面路由，对 path 属性加上 /:id，使用 router 对象的 params.id 获取</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>20、如何获取dom对象？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在页面元素标签上添加 ref=&quot;domName&quot; 属性，在方法中可以通过 this.$refs.domName 获取对应 dom 对象</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>21、vue优点？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">双向数据绑定：保留了Angular 的特点，在数据操作方面更为简单</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">组件化：保留了 React 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">视图-数据-结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式（</span> <span style="font-size: 12pt;"><a href="https://www.jianshu.com/p/af0b398602bc">https://www.jianshu.com/p/af0b398602bc</a></span><span style="font-size: 12pt;">）</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">运行速度更快：相比较与 React 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>22、vue-loader 是什么？使用它的用途有哪些？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">它是vue文件的一个加载器，将 template/js/style 转换成 js 模块</span></div><div style="text-align: start;"><span style="font-size: 12pt;">用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>23、v-model的使用？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">v-model 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：</span></div><ol><li><div style="text-align: start;"><span style="font-size: 12pt;">v-bind 绑定一个 value 属性</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">v-on 指令给当前元素绑定 input 事件</span></div></li></ol><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">如何在组件上使用 v-model</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;">自定义事件也可以用于创建支持 v-model 的自定义输入组件</span></div><div style="text-align: start;"><span style="font-size: 12pt;">记住：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;input v-model=&quot;searchText&quot;&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;">等价于：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;input</div><div><span>    </span>v-bind:value = &quot;searchText&quot;</div><div><span>    </span>v-on:input=&quot;searchText = $event.target.value&quot;</div><div>&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;">当用在组件上时，v-model 则会这样：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;custom-input</div><div><span>    </span>v-bind:value=&quot;searchText&quot;</div><div><span>    </span>v-on:input=&quot;searchText = $event&quot;</div><div>&gt;</div><div>&lt;/custom-input&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;">为了让它正常工作，这个组件内的 &lt;input&gt; 必须：</span></div><ol><li><div style="text-align: start;"><span style="font-size: 12pt;">将其 value attribute 绑定到一个名叫 value 的 prop 上</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</span></div></li></ol><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">写成代码之后是这样的：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Vue.component('custom-input', {</div><div><span>    </span>props: ['value'],</div><div><span>    </span>template: `</div><div><span>    </span><span>    </span>&lt;input</div><div><span>    </span><span>    </span><span>    </span>v-bind:value=&quot;value&quot;</div><div><span>    </span><span>    </span><span>    </span>v-on:input=&quot;$emit('input', $event.target.value)&quot;</div><div><span>    </span><span>    </span>&gt;`</div><div>})</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;">现在 v-model 就应该可以在这个组件上完美地工作起来了：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>24、说出 vue-cli 项目中 src 目录每个文件夹和文件的用法？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">assets：放静态资源</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">components：放组件</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">router：定义路由相关的配置</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">app.vue：一个应用主组件</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">main.js：入口文件</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">25、什么是 vue 的计算属性？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>好处：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">使得数据处理结构清晰</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">依赖于数据，数据更新，处理结果自动更新</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">计算属性内部 this 指向 vm 实例</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在 template 调用时，直接写计算属性名即可</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">常用的是 getter 方法，获取数据，也可以使用 set 方法改变数据</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">相较于 methods，不管依赖的数据变不变，methods 都会重新计算，但是依赖数据不变的时候 computed 从缓存中获取，不会重新计算</span><br/></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>26、分别简述 computed 和 watch 的使用场景</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>computed：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">当一个属性受多个属性影响的时候就需要用到 computed</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">如：购物车商品结算的时候</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>watch：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">当一条数据影响多条数据的时候就需要用watch</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">如：搜索数据</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>用法：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 16px;"><b>watch</b></span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>export default {</div><div>    watch: {</div><div>        'route': 'fetchData' //监听路由变化，执行 fetchData 方法</div><div>    },</div><div>    methods: {</div><div>        fetchData() {</div><div>            console.log('监听到了')</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div>export default {</div><div>    watch: {</div><div>        $route(to, from) {</div><div>            let bottomPage = ['home', 'my'];</div><div>            let toPageName = to.name;</div><div>            let isNeedShowTabbar = false;</div><div>            for (let i=0; i&lt;bottomPage.length; i++) {</div><div>                if (toPageName === bottomPage[i]) {</div><div>                    isNeedShowTabbar = true;</div><div>                    break;</div><div>                }</div><div>            }</div><div>            this.isShowTabbar = isNeedShowTabbar;</div><div>        }</div><div>    }</div><div>}</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>27、</b></span><span style="font-size: 12pt; font-weight: bold;">computed </span><span style="font-size: 12pt;"><b>和 watch 的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">计算属性是自动监听依赖值的变化，从而动态返回内容</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>区别：</b>来源于用法</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">只是需要动态值，那就用计算属性</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">需要知道值的改变后执行业务逻辑，才用 watch</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">用反或混用虽然可行，但都是不正确的用法</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>总结：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">当有一些数据需要随着另外一些数据变化时，建议使用 computed</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用 watch</span><br/></div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>28、computed 是一个对象时，它有哪些选项？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">有 get 和 set 两个选项</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>29、computed 和 methods 有什么区别？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>30、computed 是否能依赖其它组件的数据？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">computed 可以依赖其他 computed，甚至是其他组件的 data</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>31、watch 是一个对象时，它有哪些选项？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">handler：执行的函数</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">deep：是否深度</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">immediate：是否立即执行</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>32、vue初始化页面闪动问题</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于 {{message}} 的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的：</span></div><ul><li><div style="text-align: start;"><span style="font-size: 16px;">解决方式：在元素标签上添加 v-cloak 属性，在 css 文件中添加对应的样式</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//template</div><div>&lt;div class=&quot;#app&quot; v-cloak&gt;</div><div>    &lt;p&gt;{{value.name}}&lt;/p&gt;</div><div>&lt;/div&gt;</div><div><br/></div><div>//css</div><div>[v-cloak] {</div><div>    display: none;</div><div>}</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>33、vue更新数组时触发视图更新的方法</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">push()：向数组的末尾添加一个或多个元素，并返回新的长度</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">pop()：用于删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">shift()：用于把数组的第一个元素从其中删除，并返回第一个元素的值</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">unshift()：向数组的开头添加一个或更多元素，并返回新的长度</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">splice()：向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">sort()：用于对数组的元素进行排序</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">reverse()：用于颠倒数组中元素的顺序</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;">filter(), consat(), slice() 他们返回的是一个新数组，使用这些方法时，可以用新数组来替换原始数组，但是不会改变原数组值</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>34、Vue.set() 响应式新增与修改数据</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">调用方法：</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Vue.set( target, key, value )</div><div>target：要更改的数据源(可以是对象或者数组)</div><div>key：要更改的具体数据</div><div>value ：重新赋的值</div><div><br/></div><div>export default() {</div><div>    data() {</div><div>        food: {</div><div>            name: 'apple'</div><div>        }</div><div>    }</div><div>}...</div><div>Vue.set(food, 'count', 1);</div><div><br/></div><div><br/></div><div>// Vue.set()在methods中也可以写成this.$set()</div></div></div><div><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>35、$nextTick 的使用</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后，立即使用这个回调函数，获取更新后的 DOM</span><br/></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;">当你修改了 data 的值然后马上获取这个 dom 元素的值，是不能获取到更新后的值，</span><span style="font-size: 12pt;">你需要使用 $nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后再获取，才能成功</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 修改数据</div><div>vm.msg = 'Hello'// DOM 还未更新</div><div>Vue.nextTick(function () {</div><div><span>    </span>// DOM 更新</div><div>})</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>36、为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;">组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>37、渐进式框架的理解？有什么好处？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>理解：</b>简单说就是框架分层</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>如何分层（</b></span><span style="font-size: 12pt;">棒棒糖</span><span style="font-size: 12pt;"><b>）：</b>最核心的是视图层渲染，然后往外是组件机制，在此基础上再加入路由机制，再加入状态管理，最外层是构建工具，vue 和 react 都是如此</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>好处：</b>可以根据不同的需求选择不同的层级</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b><br/></b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>38、单页面应用和多页面应用区别及优缺点</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">单页面应用（SPA）：</span><span style="font-size: 12pt;">通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html/js/css，所有的页面内容都包含在这个所谓的主页面中，但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源，多应用于 pc 端</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">优点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">前后端分离</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">页面效果会比较炫酷（比如切换页面内容时的专场动画）</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">缺点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">不利于seo</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">初次加载时耗时多</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">页面复杂度提高很多</span></div></li></ul></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">多页面（MPA）：</span><span style="font-size: 12pt;">就是指一个应用中有多个页面，页面跳转时是整页刷新</span></div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>39、assets 和 static 的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>相同点：</b></span><span style="font-size: 12pt;">assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>不相同点：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">assets 中存放的静态资源文件在项目打包时，会将 assets 中放置的静态资源文件进行打包（</span><span style="font-size: 12pt;">压缩体积，代码格式化</span><span style="font-size: 12pt;">）上传</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">static 中放置的静态资源文件不会走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">static 中的资源文件由于没有进行压缩等操作，所以文件的体积相对于 assets 中打包后的文件体积较大，在服务器中就会占据更大的空间</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>建议：</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程，减少体积</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">项目中引入的第三方的资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>40、引进组件的步骤</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">在 script 的第一行用 import 引入组件路径</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在 component 中写上组件名称</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在 template 中引入组件使用</span><br/></div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><b><br/></b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>41、delete 和 Vue.delete 删除数组的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变</span></div><div style="text-align: start;"><span style="font-size: 12pt;">Vue.delete 直接删除了数组，改变了数组的键值</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>let a = [1, 2, 3, 4]</div><div>let b = [1, 2, 3, 4]</div><div>delete a[1] // [1, empty, 3, 4] 0:1 2:3 3:4</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">this.$delete(b, a) // [1, 3, 4]  0:1 1:3 2:4</span></div></div><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>42、Vue-router 跳转和 location.href 有什么区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">使用 location.href = '/url' 来跳转，简单方便，但是刷新了页面</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">使用 history.pushState('/url')，无刷新页面，静态跳转</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">引进 router，然后使用 router.push('/url') 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><b>注意：</b>其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为 vue-router 就是用了 history.pushState()，尤其是在 history 模式下</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>43、vue slot 插槽（占位/具名插槽/作用域插槽）</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">插槽可以理解为父子组件的传参，或者动态的占位符，父组件决定插槽的内容，子组件决定插槽的插在何处，作为承载分发内容的出口</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>44、RouterLink在 IE 和 Firefox 中不起作用（路由不跳转）的问题</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">只用 a 标签，不用 button 标签</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">使用 button 标签和 Router.navigate 方法</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>45、axios 的特点有哪些</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">从浏览器中创建 XMLHttpRequests</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">node.js 创建 http 请求</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">支持 Promise API</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">拦截请求和响应</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">转换请求数据和响应数据</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">取消请求</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">自动换成 json</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">axios 中的发送字段的参数是 data 跟 params 两个</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">区别</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">params 是跟请求地址一起发送的，</span><span style="font-size: 12pt;">一般适用于 get 请求</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">data 的作为一个请求体进行发送</span><span style="font-size: 12pt;">，一般适用于 post put 请求</span></div></li></ul></ul></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>46、请说下封装 vue 组件的过程？</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">建立组件的模板，搭好架子，写好样式，考虑好组件的基本逻辑</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">准备好组件的数据输入（分析好逻辑，定好 props 里面的数据、类型</span><span style="font-size: 12pt;">）</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">准备好组件的数据输出（根据组件逻辑，做好要暴露出来的方法</span><span style="font-size: 12pt;">）</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">封装完毕后，直接调用即可</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>47、params 和 query 的区别</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">用法：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">query 要用 path 来引入，params 要用 name 来引入</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">接收参数</span><span style="font-size: 12pt;">分别是 path：this.$route.query.name 和 params：this.$route.params.name</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">url地址显示：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">query 更加类似于我们 ajax 中 get 传参，</span><span style="font-size: 12pt;">在浏览器地址栏中显示参数</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">params 则类似于 post，在浏览器地址栏中不显示参数</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">注意点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">query 刷新不会丢失 query 里面的数据</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">params 刷新会丢失 params 里面的数据</span></div></li></ul></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>48、vue-router 是什么？它有哪些组件</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">vue-router 是 vue 用来写路由一个插件</span></div><div style="text-align: start;"><span style="font-size: 12pt;">它有 router-link、router-view 组件</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>49、active-class 是哪个组件的属性？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">vue-router 模块的 router-link 组件属性</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>50、vue-router 有哪几种导航钩子?（三种）</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">全局导航钩子</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">前置守卫（</span><span style="font-size: 12pt;">单独设置每个路由的属性</span><span style="font-size: 12pt;">）</span><span style="font-size: 12pt;">：</span></div></li></ul></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>meta: { </div><div><span>    </span>may: true </div><div>}</div><div>router.beforeEach((to, from, next) =&gt; {</div><div>    if (to.matched.some(item =&gt; item.meta.may)) {</div><div>        let id = window.localStorage.getItem(&quot;id&quot;)</div><div>        if (id) {</div><div>            next()</div><div>        } else {</div><div>            next({ name: &quot;login&quot; })</div><div>        }</div><div>    } else {</div><div>        next()</div><div>    }</div><div>})</div><div>注意：next 方法必须要调用，否则钩子函数无法 resolved</div></div></div><ul><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">后置钩子</span></div></li></ul></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>router.afterEach((to,from) =&gt; {</div><div>    if(to.meta &amp;&amp; to.meta.title){</div><div>        document.title = to.meta.title</div><div>    }else{</div><div>        document.title = &quot;666&quot;</div><div>    }</div><div>})</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">单独路由独享钩子</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>{</div><div>    path: '/home',</div><div>    name: 'home',</div><div>    component: Home,</div><div>    beforeEnter(to, from, next) {</div><div>        if (window.localStorage.getItem(&quot;id&quot;)) {</div><div>            next()</div><div>        } else {</div><div>            next({ name: &quot;login&quot; })</div><div>        }</div><div>    }</div><div>}</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">组件内的钩子</span></div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>beforeRouteEnter(to, from, next) {</div><div>    // do someting</div><div>    // 在渲染该组件的对应路由被 confirm 前调用</div><div>},</div><div>beforeRouteUpdate(to, from, next) {</div><div>    // do someting</div><div>    // 在当前路由改变，但是依然渲染该组件是调用</div><div>},</div><div>beforeRouteLeave(to, from ,next) {</div><div>    // do someting</div><div>    // 导航离开该组件的对应路由时被调用</div><div>}</div></div></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">全局解析守卫</span><br/></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>router.beforeResolve 注册一个全局守卫，和 router.beforeEach 类似</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>51、Vue的路由实现：hash模式 和 history模式</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">hash模式：在浏览器中符号“#”，# 以及 # 后面的字符称之为 hash，用window.location.hash读取</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">特点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com/">http://www.xxx.com</a>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误</span></div></li></ul></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 16px;">特点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id">http://www.xxx.com/items/id</a>。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</span></div></li></ul></ul></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>52、对于MVVM的理解</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">MVVM 是 Model-View-ViewModel 的缩写</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">View 代表UI 组件，它负责将数据模型转化成 UI 展现出来</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;">在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到View 上。</span><span style="font-size: 12pt;">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>53、Vue 实现数据双向绑定的原理：Object.defineProperty()</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">vue实现数据双向绑定主要是：<b>采用数据劫持结合发布者-订阅者模式的方式</b></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">vue的数据双向绑定，将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>Object.defineProperty(obj, prop, descriptor)</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">参数：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>obj：</b>要定义属性的对象</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>prop：</b>要定义或修改的属性的名称或 Symbol </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>descriptor：</b>要定义或修改的属性描述符</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>返回值：</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">被传递给函数的对象</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>注意：</b>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>js实现简单的双向绑定：</b></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;body&gt;</div><div>    &lt;div id=&quot;app&quot;&gt;</div><div>        &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;</div><div>        &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;</div><div>    &lt;/div&gt;</div><div>&lt;/body&gt;</div><div>&lt;script type=&quot;text/javascript&quot;&gt;</div><div>    var obj = {}</div><div>    Object.defineProperty(obj, 'txt', {</div><div>        get: function () {</div><div>            return obj</div><div>        },</div><div>        set: function (newValue) {</div><div>            document.getElementById('txt').value = newValue</div><div>            document.getElementById('show').innerHTML = newValue</div><div>        }</div><div>    })</div><div>    document.addEventListener('keyup', function (e) {</div><div>        obj.txt = e.target.value</div><div>    })</div><div>&lt;/script&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>54、Vue 组件间的参数传递</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">父组件与子组件传值</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">父组件传给子组件：子组件通过 props 方法接收数据</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">子组件传给父组件：$emit 方法传递参数</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">非父子组件间的数据传递，兄弟组件传值</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">eventBus</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适</span></div></li></ul></ul></ul><div style="text-align: start;"><span style="font-size: 12pt;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    1、</span>创建 eventBus.js 文件</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import Vue from 'vue';</div><div>export default new Vue();</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>2、组件中使用</span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import Bus from '../../utils/eventBus';</div><div><br/></div><div>//触发事件</div><div>Bus.$emit(&quot;searchFarmAbout&quot;, '0', '');</div><div>Bus.$emit(&quot;backView&quot;);</div><div><br/></div><div>//监听事件</div><div>Bus.$on(&quot;backView&quot;, () =&gt; {</div><div>    this.selectVal = ''</div><div>    this.searchVal = ''</div><div>    this.seachPlaceholder = '请先选择搜索项'</div><div>});</div><div>Bus.$on(&quot;searchFarmAbout&quot;, (selectVal, searchVal) =&gt; {</div><div>    this.selectVal = selectVal</div><div>    this.searchVal = searchVal</div><div>    this.seachPlaceholder = '请先选择搜索项'</div><div>});</div><div><br/></div><div>//销毁事件监听</div><div>beforeDestroy () {</div><div>    Bus.$off('backView')</div><div>    Bus.$off('searchFarmAbout')</div><div>}</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>55、vue组件间的通信</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">父子 props/event children ref provide/inject</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">兄弟 bus vuex</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">跨级 bus vuex provide.inject</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>56、Vue 与 Angular 以及 React 的区别？</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;">（版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟）</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">与AngularJS的区别</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">相同点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">都支持指令：内置指令和自定义指令</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">都支持过滤器：内置过滤器和自定义过滤器</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">都支持双向数据绑定</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">都不支持低端浏览器</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">不同点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">学习成本：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在性能上：AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的</span></div></li></ul></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">与React的区别</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">相同点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">中心思想相同：一切都是组件，组件实例之间可以嵌套</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">都提供合理的钩子函数，可以让开发者定制化地去处理需求</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">在组件开发中都支持mixins的特性</span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">不同点：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">React采用的Virtual DOM会对渲染出来的结果做脏检查</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM</span></div></li></ul></ul></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>57、vue 路由的钩子函数</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">主要用来控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改；一些需要登录才能调整页面的重定向功能</span></div><div style="text-align: start;"><span style="font-size: 12pt;">beforeEach主要有3个参数to，from，next：</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">to：route即将进入的目标路由对象</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">from：route当前导航正要离开的路由</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">next：function一定要调用该方法resolve这个钩子，执行效果依赖next方法的调用参数，可以控制网页的跳转</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;"><b>常用登陆拦截：</b></span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import Vue from 'vue'</div><div>import VueRouter from 'vue-router'</div><div>Vue.use(VueRouter)</div><div><br/></div><div>//router.js 中 添加 meta 属性</div><div>const routes = [</div><div>    {</div><div>        path: '/home',</div><div>        name: 'home',</div><div>        meta: {</div><div>            requireAuth: true</div><div>        }</div><div>    },</div><div>    {</div><div>        name: 'login',</div><div>        path: '/login'</div><div>    }</div><div>]</div><div><br/></div><div>// 解决点击同一路由控制台报错问题</div><div>const originalPush = VueRouter.prototype.push</div><div>VueRouter.prototype.push = function push(location) {</div><div>    return originalPush.call(this, location).catch(err =&gt; err)</div><div>}</div><div>const router = new VueRouter({</div><div>    routes</div><div>})</div><div><br/></div><div>// 登录拦截</div><div>router.beforeEach((from, to, next) =&gt; {</div><div>    if (to.meta.requireAuth) { // 判断跳转的路由是否需要登录</div><div>        if (store.state.token) { // vuex.state判断token是否存在</div><div>            next() // 已登录</div><div>        } else {</div><div>            next({</div><div>                path: '/login',</div><div>                query: {</div><div>                    redirect: to.fullPath // 将跳转的路由path作为参数，登录成功后跳转到该路由</div><div>                }</div><div>            })</div><div>        }</div><div>    } else {</div><div>       next()</div><div>    }</div><div>})</div><div>export default router</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>58、vue-cli如何新增自定义指令</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">创建局部指令</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var app = new Vue({</div><div>    el: '#app',</div><div>    data: {</div><div>    },</div><div>    // 创建指令(可以多个)</div><div>    directives: {</div><div>        // 指令名称</div><div>        dir1: {</div><div>            inserted(el) {</div><div>            // 指令中第一个参数是当前使用指令的DOM</div><div>                console.log(el);</div><div>                console.log(arguments);</div><div>            // 对DOM进行操作</div><div>                el.style.width = '200px';</div><div>                el.style.height = '200px';</div><div>                el.style.background = '#000';</div><div>            }</div><div>        }</div><div>    }</div><div>})</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">全局指令</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Vue.directive('dir2', {</div><div>    inserted(el) {</div><div>        console.log(el);</div><div>    }</div><div>})</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">指令的使用</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;div id=&quot;app&quot;&gt;</div><div>    &lt;div v-dir1&gt;&lt;/div&gt;</div><div>    &lt;div v-dir2&gt;&lt;/div&gt;</div><div>&lt;/div&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>59、vue如何自定义一个过滤器</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//html代码：</div><div>&lt;div id=&quot;app&quot;&gt;</div><div>    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;</div><div>    {{msg| capitalize }}</div><div>&lt;/div&gt;</div><div><br/></div><div>//JS代码：</div><div>var vm=new Vue({</div><div>    el:&quot;#app&quot;,</div><div>    data:{</div><div>        msg:''</div><div>    },</div><div>    filters: {</div><div>        capitalize: function (value) {</div><div>            if (!value) return ''</div><div>            value = value.toString()</div><div>            return value.charAt(0).toUpperCase() + value.slice(1)</div><div>        }</div><div>    }</div><div>})</div><div><br/></div><div>//全局定义过滤器</div><div>Vue.filter('capitalize', function (value) {</div><div>    if (!value) return ''</div><div>    value = value.toString()</div><div>    return value.charAt(0).toUpperCase() + value.slice(1)</div><div>})</div><div>//过滤器接收表达式的值 (msg) 作为第一个参数，capitalize 过滤器将会收到 msg 的值作为第一个参数</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>60、对keep-alive 的了解</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>使用方法：</b></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;keep-alive include='include_components' exclude='exclude_components'&gt;</div><div>    &lt;component&gt;</div><div>    &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;</div><div>    &lt;/component&gt;</div><div>&lt;/keep-alive&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>参数解释：</b></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>include：</b>字符串或正则表达式，只有名称匹配的组件会被缓存</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>exclude：</b>字符串或正则表达式，任何名称匹配的组件都不会被缓存</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">注意：</span></div></li><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">include 和 exclude 的属性允许组件有条件地缓存</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind </span></div></li></ul><li><div style="text-align: start;"><span style="font-size: 12pt;">使用示例：</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;</div><div>&lt;keep-alive include=&quot;a,b&quot;&gt;</div><div>    &lt;component&gt;&lt;/component&gt;</div><div>&lt;/keep-alive&gt;</div><div><br/></div><div>&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;</div><div>&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</div><div>    &lt;component&gt;&lt;/component&gt;</div><div>&lt;/keep-alive&gt;</div><div><br/></div><div>&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;</div><div>&lt;keep-alive :include=&quot;['a', 'b']&quot;&gt;</div><div>    &lt;component&gt;&lt;/component&gt;</div><div>&lt;/keep-alive&gt;</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>61、绑定 class 的数组用法</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">对象方法：</span><span style="font-size: 12pt;">v-bind:class=&quot;{'orange': isRipe, 'green': isNotRipe}&quot;</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">数组方法：v-bind:class=&quot;[class1, class2]&quot;</span></div></li><li><div style="text-align: start;"><span style="font-size: 12pt;">行内：v-bind:style=&quot;{color: color, fontSize: fontSize+'px' }&quot;</span></div></li></ul><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>62、怎样理解单向数据流</b></span><span style="font-size: 12pt; font-weight: bold;">？</span></div><div style="text-align: start;"><span style="font-size: 12pt;">这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案：</span></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能：</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>export default {</div><div>    props: {</div><div>        value: String</div><div>    },</div><div>    data () {</div><div>        return {</div><div>            currentValue: this.value</div><div>        }</div><div>    }</div><div>}</div></div></div><ul><li><div style="text-align: start;"><span style="font-size: 12pt;">如果是对 prop 值的转换，可以使用计算属性：</span></div></li></ul><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>export default {</div><div>    props: ['size'],</div><div>    computed: {</div><div>        normalizedSize: function () {</div><div>            return this.size.trim().toLowerCase();</div><div>        }</div><div>    }</div><div>}</div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><b>63、路由的跳转方式？</b></span></div><ul><li><div><font style="font-size: 12pt;">router-link</font></div></li><ul><li><div><font style="font-size: 12pt;">不带参数</font></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;router-link :to=&quot;{name:'home'}&quot;&gt;</div><div>&lt;router-link :to=&quot;{path:'/home'}&quot;&gt; //name,path都行, 建议用name</div><div>// 注意：router-link 中链接如果是'/'开始就是从根路由开始，如果开始不带'/'，则从当前路由开始</div></div><ul><ul><li><div><font style="font-size: 12pt;">带参数</font></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;router-link :to=&quot;{name:'home', params: {id:1}}&quot;&gt;</div><div><br/></div><div>* params传参数 (类似post)</div><div>* 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot;</div><div>* 不配置path ,第一次可请求,刷新页面id会消失</div><div>* 配置path,刷新页面id会保留</div><div>* html 取参 $route.params.id</div><div>* script 取参 this.$route.params.id</div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;router-link :to=&quot;{name:'home', query: {id:1}}&quot;&gt;</div><div><br/></div><div>* query传参数 (类似get,url后面会显示参数)</div><div>* 路由可不配置</div><div>* html 取参 $route.query.id</div><div>* script 取参 this.$route.query.id</div></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><font style="font-size: 12pt;">this.$router.push() (函数里面调用)</font></div></li><ul><li><div><font style="font-size: 12pt;">不带参数</font></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>this.$router.push('/home')</div></div><ul><ul><li><div><span style="font-size: 16px;">带参数</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>this.$router.push({name:'home'})</div><div>this.$router.push({path:'/home'})</div></div><ul><ul><ul><li><div><font style="font-size: 12pt;">query 传参</font></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>this.$router.push({name:'home',query: {id:'1'}})</div><div>this.$router.push({path:'/home',query: {id:'1'}})</div><div>* html 取参 $route.query.id</div><div>* script 取参 this.$route.query.id</div></div><ul><ul><ul><li><div><font style="font-size: 12pt;">params 传参</font></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>this.$router.push({name:'home',params: {id:'1'}}) // 只能用 name</div><div>* 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; ,</div><div>* 不配置path ,第一次可请求,刷新页面id会消失</div><div>* 配置path,刷新页面id会保留</div><div>* html 取参 $route.params.id</div><div>* script 取参 this.$route.params.id</div></div><ul><ul><ul><li><div><font style="font-size: 12pt;">query 和 params 区别</font></div></li><ul><li><div><font style="font-size: 12pt;">query 类似 get，跳转之后页面 url 后面会拼接参数，类似 ?id=1（非重要性的可以这样传，密码之类还是用 params</font><span style="font-size: 12pt;">）</span><font style="font-size: 12pt;">刷新页面 id 还在</font></div></li></ul></ul></ul></ul><ul><ul><ul><ul><li><div><font style="font-size: 12pt;">params 类似 post，跳转之后页面 url 后面不会拼接参数，但是刷新页面 id 会消失</font></div></li></ul></ul></ul></ul><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><font style="font-size: 12pt;">this.$router.replace() (用法同上 </font><span style="font-size: 12pt;">this.$router.push()</span><font style="font-size: 12pt;">)</font></div></li><li><div><font style="font-size: 12pt;">this.$router.go(n)()</font></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>this.$router.go(n)</div><div>//向前或者向后跳转n个页面，n可为正整数或负整数</div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">注意以上几种跳转方式的<b>区别：</b></font></div><ul><li><div><font style="font-size: 12pt;">this.$router.push：</font><span style="font-size: 12pt;">跳转到指定 url 路径，并想 history 栈中添加一个记录，点击后退会返回到上一个页面</span></div></li><li><div><font style="font-size: 12pt;">this.$router.replace：</font><span style="font-size: 12pt;">跳转到指定 url 路径，但是 history 栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</span></div></li><li><div><span style="font-size: 12pt;">this.$router.go(n)：</span><span style="font-size: 12pt;">向前或者向后跳转 n 个页面，n 可为正整数或负整数</span></div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 1.25rem; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span><br/></div></div></span>
</div></body></html> 